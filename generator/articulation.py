from __future__ import annotations

import random
import os

from music21 import note, volume

QL_32ND = 0.125

CC_AFTERTOUCH = 74


class ArticulationEngine:
    """Utility to generate simple glissando and trill note patterns."""

    # Set SPARKLE_DETERMINISTIC=1 to force deterministic RNG defaults for tests.
    _SPARKLE_DETERMINISTIC = os.getenv("SPARKLE_DETERMINISTIC") == "1"

    def __init__(self, rng: random.Random | None = None) -> None:
        if rng is None:
            rng = random.Random(0) if self._SPARKLE_DETERMINISTIC else random.Random()
        self.rng = rng
        self._cc_events: list[tuple[float, int, int]] = []

    @property
    def cc_events(self) -> list[tuple[float, int, int]]:
        """Return CC events generated by the last call."""
        return list(self._cc_events)

    def generate_gliss(
        self,
        start_note: note.Note | str,
        end_note: note.Note | str,
        duration_ql: float,
    ) -> list[tuple[note.Note, float]]:
        """Return notes forming a gliss from ``start_note`` to ``end_note``."""
        self._cc_events = []
        start = note.Note(start_note) if not isinstance(start_note, note.Note) else start_note
        end = note.Note(end_note) if not isinstance(end_note, note.Note) else end_note
        count = max(1, int(round(duration_ql / QL_32ND)))
        if count == 1:
            n = note.Note(start.pitch, quarterLength=duration_ql)
            return [(n, 0.0)]
        step = (end.pitch.midi - start.pitch.midi) / float(count - 1)
        events: list[tuple[note.Note, float]] = []
        offset = 0.0
        for i in range(count):
            midi = round(start.pitch.midi + step * i)
            dur = min(QL_32ND, max(0.0, duration_ql - offset))
            n = note.Note(int(midi), quarterLength=dur)
            events.append((n, offset))
            offset += QL_32ND
        return events

    def generate_trill(
        self, anchor_note: note.Note | str, duration_ql: float
    ) -> list[tuple[note.Note, float]]:
        """Return notes performing a trill around ``anchor_note``."""
        self._cc_events = []
        anchor = note.Note(anchor_note) if not isinstance(anchor_note, note.Note) else anchor_note
        alt = anchor.pitch.transpose(1)
        base_vel = (
            int(anchor.volume.velocity)
            if anchor.volume and anchor.volume.velocity is not None
            else 64
        )
        count = max(1, int(round(duration_ql / QL_32ND)))
        events: list[tuple[note.Note, float]] = []
        offset = 0.0
        use_alt = False
        for _ in range(count):
            p = alt if use_alt else anchor.pitch
            dur = min(QL_32ND, max(0.0, duration_ql - offset))
            n = note.Note(p, quarterLength=dur)
            vel = max(1, min(127, base_vel + self.rng.randint(-5, 5)))
            n.volume = volume.Volume(velocity=vel)
            events.append((n, offset))
            self._cc_events.append((offset, CC_AFTERTOUCH, self.rng.randint(0, 40)))
            offset += QL_32ND
            use_alt = not use_alt
        return events

__all__ = ["ArticulationEngine", "QL_32ND", "CC_AFTERTOUCH"]
